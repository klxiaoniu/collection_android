# Note2

## 一、抽象类和抽象方法

### （一）抽象类和抽象方法的定义格式

* 抽象方法的定义格式：

  public abstract 返回值类型 方法名（参数列表）;

* 抽象类的定义格式：

  public abstract class 类名{}

### （二）抽象类和抽象方法的注意事项

* 抽象类不能实例化
* 抽象类中不一定有方法，有抽象方法的类一定是抽象类 
* 可以有构造方法
* 抽象类的子类

  * 要么**重写抽象类中的所有抽象方法**

  * 要么是抽象类

### （三）抽象类的作用

* 抽取共性时，无法确定方法体，就把方法定义为抽象的
* 强制让子类按照某种格式重写
* 抽象方法所在的类必须是抽象类

## 二、接口

### （一）接口的定义和使用

* 接口用关键字interface来定义

  > public **interface** 接口名{}

* 接口不能实例化

* 接口和类之间是实现关系，通过implements关键字表示

  > public class 类名 **implement** 接口名 {}

* 接口的子类（实现类）

  > 要么重写接口中的所有抽象方法
  >
  > 要么是抽象类

**注意：**

1. 接口和类的实现关系，可以单实现，也可以多实现。

   > public class 类名 **implement** 接口名1, 接口名2 {}

2. 实现类还可以在继承一个类的同时实现多个接口。

   > public class 类名 extends 父类 **implements** 接口名1, 接口名2 {}



## 三、自定义异常

* 定义异常类
* 写继承关系
* 空参构造
* 代餐构造
* 意义：让控制台的报错信息更加见名知意

> 运行时：RuntimeException 核心 表示由于参数错误而导致的问题
>
> 编程时：Exception 核心 提醒程序员检查本地信息

## 四、多线程（还没学完啊啊啊啊

### （一）线程

#### 定义

线程是操作系统中能够进行运算调度的最小单位。它被包含在 [^进程]之中，是进程中的实际运作单位。

[^进程]:进程是程序的基本执行实体。

#### 状态

* 新建状态

  > 使用 **new** 关键字和 **Thread** 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 **start()** 这个线程。

* 就绪状态

  > 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。

* 运行状态

  > 如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。

* 阻塞状态

  > 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：
  >
  > - 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。
  > - 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。
  > - 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。

* 死亡状态

  > 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

### （二）创建一个线程

   Java 提供了三种创建线程的方法：

- 通过实现 **Runnable** 接口；

- 通过**继承 Thread 类本身**；

- 通过 Callable 和 Future 创建线程。

#### 1.通过实现 Runnable 接口来创建线程
#### 2.通过继承 Thread 来创建线程
#### 3.通过 Callable 和 Future 创建线程

